#
# MAL compiler
#
# Gramatica para el compilador de MAL
#
#

# Token declarations:
%token  PLUS AND NOT
%token	LSHIFT RSHIFT
%token	EQ SEMICOLON
%token	COMMENT
%token	TAG
%token	PLEFT PRIGHT
%token	JMPZ JMPN JMPA
%token	AC SP IR TIR ZERO ONE _ONE AMASK SMASK A B C D E F
%token	ALU MAR MBR

# Starting variable
%start	main

# Rules of precedence and association

# REFERENCE:
# %left - asociar a la izquierda
# %right - asociar a la derecha
# %nonassoc - sin asociacion

%{

# PERL HEADER CODE =============================================================

# USE ==========================================================================

use strict;
use warnings;

use Data::Dumper;

# CONSTANTS ====================================================================
use constant DEBUG => 1;

# Mensajes de Errores
use constant {
	_ERR_BRACKET_NOT_FOUND		=> 'Seguramente falta parentesis derecho',
	_ERR_UNRECOGNISED_EXPRESION	=> 'No se roconoce la expresion : _ERROR_',
	_ERR_UNRECOGNISED_OPERATOR	=> 'No se roconoce el operador: _ERROR_',
	_ERR_WRONG_SYNTAX	=> 'Ud. tiene un error de sintaxis cerca de: _ERROR_',
	_ERR_TOKEN_EXPECTED	=> 'Se esperaba: _ERROR_',
	_ERR_TAG_NOT_FOUND	=> 'No se encontro el tag: _ERROR_',
};

# GLOBAL VARIABLES =============================================================

my $ERRORCNT;	# Numero total de errores
my @errors;		# Array con los mensajes de cada error encontrado
my $tags;			# Hash map con la lista de tags -> nro de linea

# bus mic offset
use constant {
	BUS_A => 2**8,	# 256
	BUS_B => 2**12,	# 4096
	BUS_C => 2**16,	# 65536

	BIT_ENC	=> 2**20,
	BIT_WR	=> 2**21,
	BIT_RD	=> 2**22,
	BIT_MAR	=> 2**23,
	BIT_MBR	=> 2**24,

	SH_R => 2**25,
	SH_L => 2**26,

	ALU_PLUS => 0,
	ALU_AND => 2**27,
	ALU_IDD => 2**28,
	ALU_NOT => 3 * (2**27),

	COND_N => 2**29,
	COND_Z => 2**30,
	COND_A => 3 * (2**29),

	BIT_AMUX => 2**31
};

# END OF PERL HEADER ===========================================================

%}

%%

main:
	sent_list |
	sent_list COMMENT
;

sent_list:
	sent SEMICOLON sent_list { $_[1] | $_[3] } | { 0 }
;

sent:
	sent_alu |
	sent_io  |
	sent_jmp |
;

sent_alu:
	ALU  EQ shifter { $_[3] } |
	wreg EQ shifter { ($_[1] * BUS_C) | BIT_ENC | $_[3] } |
	MAR  EQ rreg { BIT_MAR | ALU_IDD | ($_[3] * BUS_B) } |
	MBR  EQ shifter { BIT_MBR	| $_[3] }
;

shifter:
	LSHIFT PLEFT op PRIGHT { SH_L | $_[3] } |
	RSHIFT PLEFT op PRIGHT { SH_R | $_[3] } |
	op
;

op:
	rreg AND rreg		{ ALU_AND  | ($_[3] * BUS_A) | ($_[1] * BUS_B) } |
	rreg PLUS rreg	{ ALU_PLUS | ($_[3] * BUS_A) | ($_[1] * BUS_B) } |
	NOT PLEFT rreg PRIGHT	{ ALU_NOT  | ($_[3] * BUS_A) } |
	rreg						{ ALU_IDD  | ($_[1] * BUS_A) } |

	MBR  AND rreg		{ ALU_AND | BIT_AMUX | ($_[3] * BUS_B) } |
	rreg AND MBR		{ ALU_AND | BIT_AMUX | ($_[1] * BUS_B) } |

	MBR  PLUS rreg	{ ALU_PLUS | BIT_AMUX | ($_[3] * BUS_B) } |
	rreg PLUS MBR		{ ALU_PLUS | BIT_AMUX | ($_[1] * BUS_B) } |

	NOT PLEFT MBR	PRIGHT	{ ALU_NOT | BIT_AMUX } |
	MBR							{ ALU_IDD | BIT_AMUX } |
;

wreg:
	AC | SP | IR | TIR | AMASK | SMASK | A | B | C | D | E | F
;

rreg:
	AC | SP | IR | TIR | ZERO | ONE | _ONE | AMASK | SMASK | A | B | C | D | E | F
;

sent_io:
	RD { BIT_RD } |
	WR { BIT_WR }
;

sent_jmp:
	JMPZ TAG { COND_Z | getTag($_[2]) } |
	JMPN TAG { COND_N | getTag($_[2]) } |
	JMPA TAG { COND_A | getTag($_[2]) } ;

%%

# ==============================================================================

sub run {

	my $self = shift;
	my $data = shift;

	$self -> YYData -> {INPUT} = $data;

	# Reset errors from previous runs:
	$ERRORCNT = 0;	# Numero total de errores
	@errors = ();

	# Do the job:
	return $self -> YYParse(
			yylex => \&_lexer,
			yyerror => \&_error,
			yydebug => 0x00
	);

	# Debug:
	# Bit Value    Outputs
	# 0x01         Token reading (useful for Lexer debugging)
	# 0x02         States information
	# 0x04         Driver actions (shifts, reduces, accept...)
	# 0x08         Parse Stack dump
	# 0x10         Error Recovery tracing
	# To have a full debugging ouput, use
	# debug => 0x1F
}

sub set_tags {

	my $self = shift;

	$tags = shift;

}

sub get_tag {
	my $tag = shift;

	# return  (exists $tags -> {$tag}) ? $tags -> {$tag} : 0;
	if (exists $tags -> {$tag}) {
		return $tags -> {$tag};
	} else {
		$self -> _add_error(_ERR_TAG_NOT_FOUND, $tag);
		return 0;
	}
}

sub _add_error {

	my $self = shift;

	my $msg = shift;

	while (my $val = shift) {
			$msg =~ s/_ERROR_/'$val'/;
	}
	$msg =~ s/_ERROR_//g;

	$ERRORCNT++;
	unshift @errors, $msg;
}

sub get_errors {
	my $self = shift;
	return \@errors;
}

# ==============================================================================

sub _lexer {

	my $self = shift;

	$self -> YYData -> {INPUT} or return('', undef);

	for ( $self -> YYData -> {INPUT} ) {

		s/^([\s\t\n\r]*)//; # se descartan espacios, tabuladores, saltos de linea.

		# ========================================================================
		s/^(\=|\:\=)\s*//i                   && return('EQ', $1);
		s/^(\;)\s*//i                        && return('SEMICOLON', $1);

		# Shifts =================================================================
		s/^(LSHIFT)\s*//i                    && return('LSHIFT', $1);
		s/^(RSHIFT)\s*//i                    && return('RSHIFT', $1);

		# io =====================================================================
		s/^(RD)\s*//i                        && return('RD', $1);
		s/^(WR)\s*//i                        && return('WR', $1);

		# Jumps ==================================================================
		s/^(JMPZ)\s*//i                      && return('JMPZ', $1);
		s/^(IF\s+Z\s+THEN\s+GOTO)\s*//i      && return('JMPZ', $1);
		s/^(JMPN)\s*//i                      && return('JMPN', $1);
		s/^(IF\s+N\s+THEN\s+GOTO)\s*//i      && return('JMPN', $1);
		s/^(JMPA)\s*//i                      && return('JMPA', $1);
		s/^(GOTO)\s*//i                      && return('JMPA', $1);

		# Logical operators ========================================================
		s/^(NOT|NO|INV)\s*//i                && return('NOT', $1);
		s/^(AND|Y)\s*//i                     && return('AND', $1);
		s/^(\+)\s*//i                        && return('PLUS', $1);

		# Brackets =================================================================
		s/^([\(])\s*//                       && return('PLEFT', $1);
		s/^([\)])\s*//                       && return('PRIGHT', $1);

		# Registers ================================================================
		s/^(ALU)\s*//i                       && return('ALU', $1);
		s/^(MAR)\s*//i                       && return('MAR', $1);
		s/^(MBR)\s*//i                       && return('MBR', $1);

		s/^(AC)\s*//i                        && return('AC', 1);
		s/^(SP)\s*//i                        && return('SP', 2);
		s/^(IR)\s*//i                        && return('IR', 3);
		s/^(TIR)\s*//i                       && return('TIR',4);
		s/^(0)\s*//i                         && return('ZERO', 5);
		s/^(1)\s*//i                         && return('ONE',  6);
		s/^(\-1)\s*//i                       && return('_ONE', 7);
		s/^(AMASK)\s*//i                     && return('AMASK',8);
		s/^(SMASK)\s*//i                     && return('SMASK',9);
		s/^(A)\s*//i                         && return('A',   10);
		s/^(B)\s*//i                         && return('B',   11);
		s/^(C)\s*//i                         && return('C',   12);
		s/^(D)\s*//i                         && return('D',   13);
		s/^(E)\s*//i                         && return('E',   14);
		s/^(F)\s*//i                         && return('F',   15);

		# Strings ==================================================================
		s/^[\<]\s*(\w+)\s*[\>]//             && return('TAG', $1);
		s/^[\{]\s*(.*?)[\}]//                && return('COMMENT', $1);
		s/^\#\s*(.*)$//i                     && return('COMMENT', $1);

		# If could not recognize a token and there is still something to read
		# there is an error in the expression
		my $input = $self -> YYData -> {INPUT};
		if ($input) { $self -> _add_error( _ERR_UNRECOGNISED_EXPRESION, $input); }

		# As mentioned in the Parse::Yacc help
		# we should return ('', undef) at the end
		return('', undef);

	}
}

sub _error {

	my $self = shift;

	# Token read:
	my $token = $self -> YYCurtok;

	# Value of token read
	my $value = $self -> YYCurval;

	# input not consumed
	my $input = $self -> YYData -> {INPUT} || $value;

	# list of expected tokens
	my $expected = join("' o '", grep(!/error/, $self -> YYExpect));

	$self -> _add_error( _ERR_WRONG_SYNTAX, ($input || 'fin de expresion') );
	$self -> _add_error( _ERR_TOKEN_EXPECTED, $expected );

	exists $self -> YYData -> {ERRMSG} &&
	do {
		my $description = $self -> YYData -> {ERRMSG};
		$self -> _add_error($description);
		delete $self -> YYData -> {ERRMSG};
		return;
	};

}

# ==============================================================================

1;
