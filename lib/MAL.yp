#
# MAL compiler
#
# Gramatica para el compilador de MAL
#
#

# Token declarations:
%token  PLUS AND NOT
%token	LSHIFT RSHIFT
%token	EQ SEMICOLON
%token	COMMENT
%token	TAG
%token	PLEFT PRIGHT
%token	JMPZ JMPN JMPA
%token	AC SP IR TIR ZERO ONE _ONE AMASK SMASK A B C D E F
%token	ALU MAR MBR

# Starting variable
%start	main

# Rules of precedence and association

# REFERENCE:
# %left - asociar a la izquierda
# %right - asociar a la derecha
# %nonassoc - sin asociacion

%{

# PERL HEADER CODE =============================================================

# USE ==========================================================================

use strict;
use warnings;

use Data::Dumper;

# CONSTANTS ====================================================================
use constant DEBUG => 1;

# Mensajes de Errores
use constant {
	_ERR_BRACKET_NOT_FOUND		=> 'Seguramente falta parentesis derecho',
	_ERR_UNRECOGNISED_EXPRESION	=> 'No se roconoce la expresion : _ERROR_',
	_ERR_UNRECOGNISED_OPERATOR	=> 'No se roconoce el operador: _ERROR_',
	_ERR_WRONG_SINTAX	=> 'Ud. tiene un error de sintaxis cerca de: _ERROR_',
	_ERR_TOKEN_EXPECTED	=> 'Se esperaba: _ERROR_',
	_ERR_TAG_NOT_FOUND	=> 'No se encontro el tag: _ERROR_',
};

# GLOBAL VARIABLES =============================================================

my $PARSER;

my $ERRORCNT;	# Numero total de errores
my @errors;		# Array con los mensajes de cada error encontrado
my $tags;			# Hash map con la lista de tags -> nro de linea

# bus mic offset
use constant {
	BUS_A => 2**8,	# 256
	BUS_B => 2**12,	# 4096
	BUS_C => 2**16,	# 65536

	BIT_ENC	=> 2**20,
	BIT_WR	=> 2**21,
	BIT_RD	=> 2**22,
	BIT_MAR	=> 2**23,
	BIT_MBR	=> 2**24,

	SH_R => 2**25,
	SH_L => 2**26,

	ALU_PLUS => 0,
	ALU_AND => 2**27,
	ALU_IDD => 2**28,
	ALU_NOT => 3 * (2**27),

	COND_N => 2**29,
	COND_Z => 2**30,
	COND_A => 3 * (2**29),

	BIT_AMUX => 2**31
};

# END OF PERL HEADER ===========================================================

%}

%%

main:
		sent_list |
		sent_list COMMENT
;

sent_list:
		sent SEMICOLON sent_list { $_[1] | $_[3] } | { 0 }
;

sent:
		sent_alu |
		sent_io  |
		sent_jmp |
;

sent_alu:
				ALU  EQ shifter { $_[3] } |
				wreg EQ shifter { ($_[1] * BUS_C) | BIT_ENC | $_[3] } |
				MAR  EQ rreg { BIT_MAR | ALU_IDD | ($_[3] * BUS_B) } |
				MBR  EQ shifter { BIT_MBR	| $_[3] }
;

shifter:
		LSHIFT PLEFT op PRIGHT { SH_L | $_[3] } |
		RSHIFT PLEFT op PRIGHT { SH_R | $_[3] } |
		op
;

op:
		rreg AND rreg		{ ALU_AND  | ($_[3] * BUS_A) | ($_[1] * BUS_B) } |
		rreg PLUS rreg	{ ALU_PLUS | ($_[3] * BUS_A) | ($_[1] * BUS_B) } |
		NOT PLEFT rreg PRIGHT	{ ALU_NOT  | ($_[3] * BUS_A) } |
		rreg						{ ALU_IDD  | ($_[1] * BUS_A) } |

		MBR  AND rreg		{ ALU_AND | BIT_AMUX | ($_[3] * BUS_B) } |
		rreg AND MBR		{ ALU_AND | BIT_AMUX | ($_[1] * BUS_B) } |

		MBR  PLUS rreg	{ ALU_PLUS | BIT_AMUX | ($_[3] * BUS_B) } |
		rreg PLUS MBR		{ ALU_PLUS | BIT_AMUX | ($_[1] * BUS_B) } |

		NOT PLEFT MBR	PRIGHT	{ ALU_NOT | BIT_AMUX } |
		MBR							{ ALU_IDD | BIT_AMUX } |
;

wreg:
		AC | SP | IR | TIR | AMASK | SMASK | A | B | C | D | E | F
;

rreg:
		AC | SP | IR | TIR | ZERO | ONE | _ONE | AMASK | SMASK | A | B | C | D | E | F
;

sent_io:
		RD { BIT_RD } |
		WR { BIT_WR }
;

sent_jmp:
		JMPZ TAG { COND_Z | getTag($_[2]) } |
		JMPN TAG { COND_N | getTag($_[2]) } |
		JMPA TAG { COND_A | getTag($_[2]) } ;

%%

# ==============================================================================
sub getTag {
		my $tag = shift;

		# return  (exists $tags -> {$tag}) ? $tags -> {$tag} : 0;
		if (exists $tags -> {$tag}) {
			return $tags -> {$tag};
		} else {
			addError(_ERR_TAG_NOT_FOUND, $tag);
			return 0;
		}
}

# ==============================================================================

sub _Error {
		# Control Personalizado de errores =========================================
		my $parser = shift;

		# Token leido:
		my $token = $parser -> YYCurtok;
		# Valor del token leido
		my $value = $parser -> YYCurval;
		# la tira sin consumir
		my $input = $parser -> YYData -> {INPUT} || $value;
		# lista de los tokens que se esperaban
		my $expected = join("' o '", grep(!/error/, $parser -> YYExpect));

		addError( _ERR_WRONG_SINTAX, ($input || 'fin de expresion') );
		addError( _ERR_TOKEN_EXPECTED, $expected );

   	exists $parser -> YYData -> {ERRMSG} &&
		do {
				my $descerr = $parser -> YYData -> {ERRMSG};
				addError($descerr);
				delete $parser -> YYData -> {ERRMSG};
				return;
		};
}

sub addError {
		my $msg = shift;

		while (my $val = shift) {
				$msg =~ s/_ERROR_/'$val'/;
		}
		$msg =~ s/_ERROR_//g;

    $ERRORCNT++;
    unshift @errors, $msg;
}

sub getErrors {
    my $self = shift;
    return \@errors;
}

# ==============================================================================

sub _Lexer {

	my $parser = shift;

	$parser -> YYData -> {INPUT} or
	return('', undef);

	for ( $parser -> YYData -> {INPUT} ) {

		s/^([\s\t\n\r]*)//; # se descartan espacios, tabuladores, saltos de linea.

		# ==========================================================================
		s/^(\=|\:\=)\s*//i						&& return('EQ', $1);
		s/^(\;)\s*//i									&& return('SEMICOLON', $1);

		# Shifts ===================================================================
		s/^(LSHIFT)\s*//i							&& return('LSHIFT', $1);
		s/^(RSHIFT)\s*//i							&& return('RSHIFT', $1);

		# io =======================================================================
		s/^(RD)\s*//i									&& return('RD', $1);
		s/^(WR)\s*//i									&& return('WR', $1);

		# Saltos ===================================================================
		s/^(JMPZ)\s*//i								&& return('JMPZ', $1);
		s/^(IF\s+Z\s+THEN\s+GOTO)\s*//i		&& return('JMPZ', $1);
		s/^(JMPN)\s*//i								&& return('JMPN', $1);
		s/^(IF\s+N\s+THEN\s+GOTO)\s*//i		&& return('JMPN', $1);
		s/^(JMPA)\s*//i								&& return('JMPA', $1);
		s/^(GOTO)\s*//i										&& return('JMPA', $1);


		# Operadores Logicos =======================================================
		s/^(NOT|NO|INV)\s*//i					&& return('NOT', $1);
		s/^(AND|Y)\s*//i							&& return('AND', $1);
		s/^(\+)\s*//i									&& return('PLUS', $1);

		# Parentesis ===============================================================
		s/^([\(])\s*// 								&& return('PLEFT', $1);
		s/^([\)])\s*// 								&& return('PRIGHT', $1);

		# Registros ================================================================
		s/^(ALU)\s*//i	 							&& return('ALU', $1);
		s/^(MAR)\s*//i	 							&& return('MAR', $1);
		s/^(MBR)\s*//i	 							&& return('MBR', $1);

		s/^(AC)\s*//i 								&& return('AC', 1);
		s/^(SP)\s*//i 								&& return('SP', 2);
		s/^(IR)\s*//i 								&& return('IR', 3);
		s/^(TIR)\s*//i 								&& return('TIR',4);
		s/^(0)\s*//i 									&& return('ZERO', 5);
		s/^(1)\s*//i 									&& return('ONE',  6);
		s/^(\-1)\s*//i	 							&& return('_ONE', 7);
		s/^(AMASK)\s*//i 							&& return('AMASK',8);
		s/^(SMASK)\s*//i 							&& return('SMASK',9);
		s/^(A)\s*//i		 							&& return('A',   10);
		s/^(B)\s*//i		 							&& return('B',   11);
		s/^(C)\s*//i		 							&& return('C',   12);
		s/^(D)\s*//i		 							&& return('D',   13);
		s/^(E)\s*//i		 							&& return('E',   14);
		s/^(F)\s*//i		 							&& return('F',   15);

		# Strings ==================================================================
		s/^[\<]\s*(\w+)\s*[\>]//		 	&& return('TAG', $1);
		s/^[\{]\s*(.*?)[\}]// 				&& return('COMMENT', $1);
		s/^\#\s*(.*)$//i							&& return('COMMENT', $1);

		# Si no reconozco un token y todavia hay tira por leer
		# hay un error en la expresion
		my $input = $parser -> YYData -> {INPUT};
		if ($input) { addError( _ERR_UNRECOGNISED_EXPRESION, $input); }

		# Segun lo especificado en la ayuda Parse::Yacc
		# al terminar se debe retornar ('', undef)
		return('', undef);

	}
}

# ==============================================================================

sub setTags {
	my $self = shift;

	$tags = shift;

}

sub run {

		my $self = shift;
		my $data = shift;

		$self -> YYData -> {INPUT} = $data;

		# Reset errors from previous runs:
		$ERRORCNT = 0;	# Numero total de errores
		@errors = ();

		# Do the job:
		return $self -> YYParse(
				yylex => \&_Lexer,
				yyerror => \&_Error,
				yydebug => 0x00
		);

		# Debug:
    # Bit Value    Outputs
    # 0x01         Token reading (useful for Lexer debugging)
    # 0x02         States information
    # 0x04         Driver actions (shifts, reduces, accept...)
    # 0x08         Parse Stack dump
    # 0x10         Error Recovery tracing
		# To have a full debugging ouput, use
    # debug => 0x1F
}

sub dbg {
		# Funcion para debuggear:
		my $msg = shift;
		warn "[WARNING] : SAYS: ". $msg if (DEBUG)
}

# ==============================================================================




# ==============================================================================

1;
